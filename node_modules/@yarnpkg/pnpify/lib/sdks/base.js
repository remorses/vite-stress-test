"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BASE_SDKS = exports.generateFlowBinBaseWrapper = exports.generateSvelteLanguageServerBaseWrapper = exports.generateStylelintBaseWrapper = exports.generateTypescriptBaseWrapper = exports.generateTypescriptLanguageServerBaseWrapper = exports.generatePrettierBaseWrapper = exports.generateEslintBaseWrapper = void 0;
const generateSdk_1 = require("../generateSdk");
const generateEslintBaseWrapper = async (pnpApi, target) => {
    const wrapper = new generateSdk_1.Wrapper(`eslint`, { pnpApi, target });
    await wrapper.writeManifest();
    await wrapper.writeBinary(`bin/eslint.js`);
    await wrapper.writeFile(`lib/api.js`);
    return wrapper;
};
exports.generateEslintBaseWrapper = generateEslintBaseWrapper;
const generatePrettierBaseWrapper = async (pnpApi, target) => {
    const wrapper = new generateSdk_1.Wrapper(`prettier`, { pnpApi, target });
    await wrapper.writeManifest();
    await wrapper.writeBinary(`index.js`);
    return wrapper;
};
exports.generatePrettierBaseWrapper = generatePrettierBaseWrapper;
const generateTypescriptLanguageServerBaseWrapper = async (pnpApi, target) => {
    const wrapper = new generateSdk_1.Wrapper(`typescript-language-server`, { pnpApi, target });
    await wrapper.writeManifest();
    await wrapper.writeBinary(`lib/cli.js`);
    return wrapper;
};
exports.generateTypescriptLanguageServerBaseWrapper = generateTypescriptLanguageServerBaseWrapper;
const generateTypescriptBaseWrapper = async (pnpApi, target) => {
    const tsServerMonkeyPatch = `
    tsserver => {
      // VSCode sends the zip paths to TS using the "zip://" prefix, that TS
      // doesn't understand. This layer makes sure to remove the protocol
      // before forwarding it to TS, and to add it back on all returned paths.

      const {isAbsolute} = require(\`path\`);

      const Session = tsserver.server.Session;
      const {onMessage: originalOnMessage, send: originalSend} = Session.prototype;
      let isVSCode = false;

      return Object.assign(Session.prototype, {
        onMessage(/** @type {string} */ message) {
          const parsedMessage = JSON.parse(message)

          if (
            parsedMessage != null &&
            typeof parsedMessage === 'object' &&
            parsedMessage.arguments &&
            parsedMessage.arguments.hostInfo === 'vscode'
          ) {
            isVSCode = true;
          }

          return originalOnMessage.call(this, JSON.stringify(parsedMessage, (key, value) => {
            return typeof value === 'string' ? removeZipPrefix(value) : value;
          }));
        },

        send(/** @type {any} */ msg) {
          return originalSend.call(this, JSON.parse(JSON.stringify(msg, (key, value) => {
            return typeof value === 'string' ? addZipPrefix(value) : value;
          })));
        }
      });

      function addZipPrefix(str) {
        // We add the \`zip:\` prefix to both \`.zip/\` paths and virtual paths
        if (isAbsolute(str) && !str.match(/^\\^zip:/) && (str.match(/\\.zip\\//) || str.match(/\\$\\$virtual\\//))) {
          // Absolute VSCode \`Uri.fsPath\`s need to start with a slash.
          // VSCode only adds it automatically for supported schemes,
          // so we have to do it manually for the \`zip\` scheme.
          // The path needs to start with a caret otherwise VSCode doesn't handle the protocol
          // https://github.com/microsoft/vscode/issues/105014#issuecomment-686760910
          return \`\${isVSCode ? '^' : ''}zip:\${str.replace(/^\\/?/, \`/\`)}\`;
        } else {
          return str;
        }
      }

      function removeZipPrefix(str) {
        return process.platform === 'win32'
          ? str.replace(/^\\^?zip:\\//, \`\`)
          : str.replace(/^\\^?zip:/, \`\`);
      }
    };
  `;
    const wrapper = new generateSdk_1.Wrapper(`typescript`, { pnpApi, target });
    await wrapper.writeManifest();
    await wrapper.writeBinary(`bin/tsc`);
    await wrapper.writeBinary(`bin/tsserver`);
    await wrapper.writeFile(`lib/tsc.js`);
    await wrapper.writeFile(`lib/tsserver.js`, { wrapModule: tsServerMonkeyPatch });
    await wrapper.writeFile(`lib/typescript.js`);
    return wrapper;
};
exports.generateTypescriptBaseWrapper = generateTypescriptBaseWrapper;
const generateStylelintBaseWrapper = async (pnpApi, target) => {
    const wrapper = new generateSdk_1.Wrapper(`stylelint`, { pnpApi, target });
    await wrapper.writeManifest();
    await wrapper.writeBinary(`bin/stylelint.js`);
    await wrapper.writeFile(`lib/index.js`);
    return wrapper;
};
exports.generateStylelintBaseWrapper = generateStylelintBaseWrapper;
const generateSvelteLanguageServerBaseWrapper = async (pnpApi, target) => {
    const wrapper = new generateSdk_1.Wrapper(`svelte-language-server`, { pnpApi, target });
    await wrapper.writeManifest();
    await wrapper.writeBinary(`bin/server.js`);
    return wrapper;
};
exports.generateSvelteLanguageServerBaseWrapper = generateSvelteLanguageServerBaseWrapper;
const generateFlowBinBaseWrapper = async (pnpApi, target) => {
    const wrapper = new generateSdk_1.Wrapper(`flow-bin`, { pnpApi, target });
    await wrapper.writeManifest();
    await wrapper.writeBinary(`cli.js`);
    return wrapper;
};
exports.generateFlowBinBaseWrapper = generateFlowBinBaseWrapper;
exports.BASE_SDKS = [
    [`eslint`, exports.generateEslintBaseWrapper],
    [`prettier`, exports.generatePrettierBaseWrapper],
    [`typescript-language-server`, exports.generateTypescriptLanguageServerBaseWrapper],
    [`typescript`, exports.generateTypescriptBaseWrapper],
    [`stylelint`, exports.generateStylelintBaseWrapper],
    [`svelte-language-server`, exports.generateSvelteLanguageServerBaseWrapper],
    [`flow-bin`, exports.generateFlowBinBaseWrapper],
];
